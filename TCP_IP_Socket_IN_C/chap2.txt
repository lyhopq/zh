
+ 基本 TCP Socket +[chap2-basic]

现在是你学习 如何写自己的套接字应用程序的时候了。我们将从YCP开始。现在你或许已经做好了直接写一些实际的代码的时候了，因此我们开始进行一个TCP客户端和服务器的工作实例。然后我们呈现在基本TCP中使用的套接字API的细节。为了使事情变得简单，我们最初的代码使用一个特定的IP版本：IPv4，它现在，在很大程度上，仍然在网际协议中占主导地位。在本章的结尾部分，我们讲呈现客户端和服务器的IPv6改进版本。在[第三章 #chap3]我们将要示范创建与协议无关的应用程序。

我们的客户端和服务器例子执行 //echo// 协议。它的工作原理如下：客户端连接到服务器病发送它的数据。服务器简单的回显他所收到的信息到客户端并断开连接。在我们的应用程序中，客户端发送的数据是一个作为提供给命令行参数的字符串。我们的客户端将打印它从服务器收到的数据，这样我们就能看见传回来的是什么东西。许多系统都有一个回显服务来进行调试和测试。

++ IPv4 TCP 客户端 ++[v4_TCP_client]

客户端和服务器之间的区别是非常重要的，因为它们在通信中使用套接字接口的某些步骤不一样。我们首先关注客户端。它的工作就是初始与服务器的通信，服务器被动的等待连接。

典型的TCP客户端通信涉及四个基本步骤：
+ 使用 ``socket()`` 创造一个TCP套接字。
+ 使用 ``connect()`` 与服务器建立连接。
+ 使用 ``send()`` 和 ``recv()`` 通信。
+ 使用 ``close()`` 关闭连接。


``TCPEchoClient4.c`` 是IPv4的TCP回显客户端的实现。

**TCPEchoClient4.c**
----------------------------
%!include: ``code/chap1/TCPEchoClient4.c``

我们的 ``TCPEchoClient4.c`` 做以下事情：

+ **程序建立和参数分析**：1-21行
 - **包含文件**：1-9行
 : 
这些头文件定义了API的标准的函数和常量。查阅你的文档（例如：man手册）的适当头文件找到你系统的套接字函数和数据结构。我们使用我们自己的包含文件：``Practical.h``，有我们自己的函数原型，将在下面描述。

 - **典型的参数分析和完整性检查**：13-21行
 : 
 IPv4地址和回显的字符串作为前两个参数被传递进来。可选择的，客户端把第三个参数作为服务器的端口。如果没有端口参数提供，客户端使用众所周知的回显协议端口：7。
+ **TCP套接字创建**：23-26行
 : 
 我们使用``socket()``函数来创建一个套接字。该套接字对应的是IPv4（AF_INET)，使用叫做TCP（IPPORT_TCP）的流式协议（SOCK_STREAM）。如果成功，``socket()``返回一个整形描述符或“句柄”。如果失败，将返回-1，此时我们调用我们的错误处理函数：``DieWithSystemMessage()``（在后面描述），来打印一个消息来示意并且退出。

+ **准备地址和建立连接**：28-42行
 - **准备sockaddr_in结构体来保存服务器地址**：29-30行
 : 
 连接到一个套接字，我们必须指定连接到的地址和端口。**sockaddr_in**结构体被定义为这些信息的“容器”。调用函数``memset()``的作用是确保我们不需要该结构体中的任何部分都被置零。
 - **填充sockaddr_in**：31-38行
 : 
 我们必须设置地址族（AF_INET），网络地址和端口号。函数``inet_pton()``把服务器的网络地址（作为命令行参数传递了的四点分记法）的字符表示法转换为32位二进制表示法。服务器的端口号在早先已经从命令行字符串转换到了二进制；调用函数``htons()``（"hosttonetworkshort"）确保二进制值格式化为API所需要的。（为什么这样做将在[第五章 #chap5]描述。）
 - **连接**：40-42行
 : 
 函数 ``connect()`` 在所给的socket和 **sockaddr_in** 结构体中由地址和端口所指定的套接字之间建立连接。因为套接字的API是一般形式的，所以指向 ``sockaddr_in`` 地址的结构体指针需要//转换//--cast--成一般的类型(**sockaddr***)，而且必须提供结构体的大小。

+ **发送回显字符串到服务器**：44-51行
 : 
我们找到参数字符串的长度并把它村起来供以后使用。一个指向回显字符串的指针传递到 ``send()`` 函数；该字符串在程序开始的时候被存储到某个位置（如同其它的命令行参数一样。）我们不必要关心它在那个地方；我们仅仅需要知道的是它的第一个字节的地址和有多少字节要被发送。（注意我们不发送字符串结束标记字符(0)，它是参数字符串的结尾——也是所有C中字符串的结尾）``send()``函数如果成功的话返回它所发送的字节数，否则返回-1。如果``send()``失败活发送了错误的自
字节数，我们必须处理这个错误。注意发送错误的字节数在这里将不会出现。不过，有测试代码会是一个好主意，因为在某些情况下错误会发生。

+ **接收回显服务的应答**：53-70行
 : 
TCP是一个字节流的协议。牵扯到这种类型的协议的是``send()``函数的边界没有保留。换句话说：**在连接的一端调用``send()``发送的字节不会在另一端调用一次``recv()``就会全部返回。**（我们将在[第七章 #chap7]详细的讨论这一问题。）因此，我们需要重复的接收字节直到和我们发送的一样多。在所有的可能性中，该循环有被执行一次的情况，因为在服务器上的数据实际上可以被一次返回；然而，这不是//保证//发生的，所以我们不得不允许多次读取需求的可能性。这是写使用套接字程序的基本原则：**你决不要假设网络和另一端的程序将会如何去做。**
 - **接受字节块**：57-65行 
 : 
 ``recv()``阻塞直到数据可用为止，它返回拷贝到缓冲的字节数或者在失败的时候返回-1。返回值为0的时候表示在另一端的应用程序关闭了TCP连接。注意到传递到``recv()``函数的字节大小参数为添加一个终止字符保留了空间。
 - **打印缓冲**：66-77行
 : 
 我们打印由服务器发送的数据，也是服务器所接收的。我们在每一个接收快的结尾添加一个结束标志(0)，因此它可以被``fputs()``作为一个字符串。我们没有检查接收到的数据是否和发送的一致。服务器可以发送完全不一样的东西（直到和我们发送的字符串长度一样），并且它将被写到标准输出。
 - **打印新行**：70行
 : 
 当接收到和发送的一样多的字节时，我们结束循环并且打印一个新行。

+ **结束连接病退出**：72-73行
 : 
 ``close()``函数通知远端套接字连接被终止了，然后解除套接字使用的本地资源。


处理函数：
```
DieWithUserMessage(const char *msg, const char *detail)
DieWithSystemMessage(const char *msg)
```

这两个函数打印用户提供的消息（//msg//）到//stderr//，还有一个详细的消息字符串；然后它们调用一个带有错误返回码的``exit()``函数，来终止应用程序。

它们的唯一区别是详细消息的来源。对于``DieWithUserMessage()``函数，详细消息是用户提供的。对于``DieWithSystemMessage()``函数，详细消息是由系统基于特定的//errno//（它描述了最近失败的原因，如果有的话）值来提供的。我们仅仅只在错误状态是由调用一个系统函数时设置了//errno//时，来调用``DieWithSystemMessage()``。（为了使程序简单，我们的示例没有包含太多的从错误中恢复的代码——只是简单的
--punt--和退出。作品级的代码不会这样轻易的放弃的。）





