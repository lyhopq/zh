
+ 基本 TCP Socket +[chap2-basic]

现在是你学习 如何写自己的套接字应用程序的时候了。我们将从YCP开始。现在你或许已经做好了直接写一些实际的代码的时候了，ockaddr_in**结构体，此我们开始进行一个TCP客户端和服务器的工作实例。然后我们呈现在基本TCP中使用的套接字API的细节。为了使事情变得简单，我们最初的代码使用一个特定的IP版本：IPv4，它现在，在很大程度上，仍然在网际协议中占主导地位。在本章的结尾部分，我们讲呈现客户端和服务器的IPv6改进版本。在[第三章 #chap3]我们将要示范创建与协议无关的应用程序。

我们的客户端和服务器例子执行 //echo// 协议。它的工作原理如下：客户端连接到服务器病发送它的数据。服务器简单的回显他所收到的信息到客户端并断开连接。在我们的应用程序中，客户端发送的数据是一个作为提供给命令行参数的字符串。我们的客户端将打印它从服务器收到的数据，这样我们就能看见传回来的是什么东西。许多系统都有一个回显服务来进行调试和测试。

++ IPv4 TCP 客户端 ++[v4_TCP_client]

客户端和服务器之间的区别是非常重要的，因为它们在通信中使用套接字接口的某些步骤不一样。我们首先关注客户端。它的工作就是初始与服务器的通信，服务器被动的等待连接。

典型的TCP客户端通信涉及四个基本步骤：
+ 使用 ``socket()`` 创造一个TCP套接字。
+ 使用 ``connect()`` 与服务器建立连接。
+ 使用 ``send()`` 和 ``recv()`` 通信。
+ 使用 ``close()`` 关闭连接。


``TCPEchoClient4.c`` 是IPv4的TCP回显客户端的实现。

**TCPEchoClient4.c**
----------------------------
%!include: ``code/chap2/TCPEchoClient4.c``

我们的 ``TCPEchoClient4.c`` 做以下事情：

+ **程序建立和参数分析**：1-21行
 - **包含文件**：1-9行
 : 
这些头文件定义了API的标准的函数和常量。查阅你的文档（例如：man手册）的适当头文件找到你系统的套接字函数和数据结构。我们使用我们自己的包含文件：``Practical.h``，有我们自己的函数原型，将在下面描述。

 - **典型的参数分析和完整性检查**：13-21行
 : 
 IPv4地址和回显的字符串作为前两个参数被传递进来。可选择的，客户端把第三个参数作为服务器的端口。如果没有端口参数提供，客户端使用众所周知的回显协议端口：7。
+ **TCP套接字创建**：23-26行
 : 
 我们使用``socket()``函数来创建一个套接字。该套接字对应的是IPv4（AF_INET)，使用叫做TCP（IPPORT_TCP）的流式协议（SOCK_STREAM）。如果成功，``socket()``返回一个整形描述符或“句柄”。如果失败，将返回-1，此时我们调用我们的错误处理函数：``DieWithSystemMessage()``（在后面描述），来打印一个消息来示意并且退出。

+ **准备地址和建立连接**：28-42行
 - **准备sockaddr_in结构体来保存服务器地址**：29-30行
 : 
 连接到一个套接字，我们必须指定连接到的地址和端口。**sockaddr_in**结构体被定义为这些信息的“容器”。调用函数``memset()``的作用是确保我们不需要该结构体中的任何部分都被置零。
 - **填充sockaddr_in**：31-38行
 : 
 我们必须设置地址族（AF_INET），网络地址和端口号。函数``inet_pton()``把服务器的网络地址（作为命令行参数传递了的四点分记法）的字符表示法转换为32位二进制表示法。服务器的端口号在早先已经从命令行字符串转换到了二进制；调用函数``htons()``（"hosttonetworkshort"）确保二进制值格式化为API所需要的。（为什么这样做将在[第五章 #chap5]描述。）
 - **连接**：40-42行
 : 
 函数 ``connect()`` 在所给的socket和 **sockaddr_in** 结构体中由地址和端口所指定的套接字之间建立连接。因为套接字的API是一般形式的，所以指向 ``sockaddr_in`` 地址的结构体指针需要//转换//--cast--成一般的类型(**sockaddr***)，而且必须提供结构体的大小。

+ **发送回显字符串到服务器**：44-51行
 : 
我们找到参数字符串的长度并把它村起来供以后使用。一个指向回显字符串的指针传递到 ``send()`` 函数；该字符串在程序开始的时候被存储到某个位置（如同其它的命令行参数一样。）我们不必要关心它在那个地方；我们仅仅需要知道的是它的第一个字节的地址和有多少字节要被发送。（注意我们不发送字符串结束标记字符(0)，它是参数字符串的结尾??????也是所有C中字符串的结尾）``send()``函数如果成功的话返回它所发送的字节数，否则返回-1。如果``send()``失败活发送了错误的自
字节数，我们必须处理这个错误。注意发送错误的字节数在这里将不会出现。不过，有测试代码会是一个好主意，因为在某些情况下错误会发生。

+ **接收回显服务的应答**：53-70行
 : 
TCP是一个字节流的协议。牵扯到这种类型的协议的是``send()``函数的边界没有保留。换句话说：**在连接的一端调用``send()``发送的字节不会在另一端调用一次``recv()``就会全部返回。**（我们将在[第七章 #chap7]详细的讨论这一问题。）因此，我们需要重复的接收字节直到和我们发送的一样多。在所有的可能性中，该循环有被执行一次的情况，因为在服务器上的数据实际上可以被一次返回；然而，这不是//保证//发生的，所以我们不得不允许多次读取需求的可能性。这是写使用套接字程序的基本原则：**你决不要假设网络和另一端的程序将会如何去做。**
 - **接受字节块**：57-65行 
 : 
 ``recv()``阻塞直到数据可用为止，它返回拷贝到缓冲的字节数或者在失败的时候返回-1。返回值为0的时候表示在另一端的应用程序关闭了TCP连接。注意到传递到``recv()``函数的字节大小参数为添加一个终止字符保留了空间。
 - **打印缓冲**：66-77行
 : 
 我们打印由服务器发送的数据，也是服务器所接收的。我们在每一个接收快的结尾添加一个结束标志(0)，因此它可以被``fputs()``作为一个字符串。我们没有检查接收到的数据是否和发送的一致。服务器可以发送完全不一样的东西（直到和我们发送的字符串长度一样），并且它将被写到标准输出。
 - **打印新行**：70行
 : 
 当接收到和发送的一样多的字节时，我们结束循环并且打印一个新行。

+ **结束连接病退出**：72-73行
 : 
 ``close()``函数通知远端套接字连接被终止了，然后解除套接字使用的本地资源。


处理函数：
```
DieWithUserMessage(const char *msg, const char *detail)
DieWithSystemMessage(const char *msg)
```

这两个函数打印用户提供的消息（//msg//）到//stderr//，还有一个详细的消息字符串；然后它们调用一个带有错误返回码的``exit()``函数，来终止应用程序。

它们的唯一区别是详细消息的来源。对于``DieWithUserMessage()``函数，详细消息是用户提供的。对于``DieWithSystemMessage()``函数，详细消息是由系统基于特定的//errno//（它描述了最近失败的原因，如果有的话）值来提供的。我们仅仅只在错误状态是由调用一个系统函数时设置了//errno//时，来调用``DieWithSystemMessage()``。（为了使程序简单，我们的示例没有包含太多的从错误中恢复的代码??????只是简单的
--punt--和退出。作品级的代码不会这样轻易的放弃的。）

偶尔，我们需要提供给用户一些信息而不退出程序；如果我们需要格式化功能的话则使用``printf()``函数，其它情况下使用``fputs()``函数。特别的，在输出固定的，预先格式化的字符串时，我们尽量不要使用``printf()``函数。**你//绝不要//干的一件事情是：把从网络接收的文本作为第一个字符串传给``printf()``函数。这样做会产生一个严重的安全漏洞。在这种情况下使用``fputs()``代替。**

: 
**注意：**函数``DieWith...()``在头文件``"Practical.h"``中//申明//。然而，这些函数的//实现//在``DieWithMessage.c``中，它应该被本文说有的例子程序编译和连接。


**DieWithMessage.c**
----------------------------
%!include: ``code/chap2/DieWithMessage.c``


如果我们编译了``TCPEchoClient4.c``和``DieWithMessage.c``将会生成程序``TCPEchoClient4，我们可以使用如下方式和一个网络地址为``169.1.1.1``的回显服务器通信：
: 
```
%TCPEchoClient4 169.1.1.1 "Echo this!"
Received: Echo this!
```

为了使客户端能够工作，我们需要服务程序。许多系统有回显服务用来调试和测试；然而，为了安全起见，这些服务在初始化是被禁用的。如果你不能访问回显服务，没有关系因为我们将要写一个。


++ IPv4 TCP 服务器 ++

现在我们把注意力集中在TCP服务器上。该服务器的工作是建立一个通信端点和被动的等待客户端的连接。TCP服务器通信有四个基本步骤：
 + 使用``socket()``产生一个TCP套接字。
 + 使用``bind()``给该套接字分配一个端口号。
 + 使用``listen()``告诉系统该端口允许接受连接。
 + 重复的做一下事情：
  - 调用``accept()``给每一个客户端连接一个套接字。
  - 通过新的套接字使用``send()``和``recv()``与客户端通信。
  - 使用``close()``关闭客户端的连接。


建造一个套接字，发送，接收，关闭这和客户端是一样的。不同之处在于在服务器中的套接字必须要和一个地址绑定,然后使用该套接字作为一种方式来获得与客户端连接的套接字。（我们将在下面的代码中阐述这一点。）服务器和每一个客户端的连接可以使这样简单：它简单的在客户端连接时接收数据并吧接收的数据返回客户端；他重复这一过程直到客户端结束连接，至此就不再有数据到来。

**TCPEchoCServer4.c**
---------------------------
%!include: ``code/chap2/TCPEchoServer4.c``

+ **程序建立和参数解析** ：1-17行
 : 
 我们使用``atoi()``把端口号从字符串转换到数字值；如果第一个参数不是数，``atoi()``将返回0，这将会产生一个错误在我们调用``bind()``的时候。
+ **套接字生成和建立**：19-37行
 - **生成一个TCP套接字**：20-37行
 : 
 生成一个流失套接字就像我们在客户端中做的一样。
 - **找到想要的端点地址**：25-29行
 : 
 在服务器端，我们需要把我们的服务端套接字与一个地址和端口号联系起来，这样客户端的连接才能找到正确的地方。既然本程序是为IPv4写的，我们就给它使用**sockaddr_in**结构体。因为我们并不关心所连接的地址（指定到运行该服务器的机器的如何地址都可以。）在设置**sockaddr_in**地址和端口号之前，我们使用``htonl()``和
 ``htons``把它们分别转换到网络字节序。（详见[5.1.2 #chap5_1_2]）
 - **绑定套接字到指定地址和端口**：32-33行
 : 
 如上面所注解，服务器套接字需要和一个本地地址和端口相关联；完成这一过程的是``bind()``函数。注意**客户端必须给``connect()``提供服务器的地址，二服务器必须给``bind()``指定//它自己//的地址。**就是有这一信息（如：服务器的地址和端口），它们才同意通信。注意``bind()``失败有几种原因；其中最重要的一种是有其它的套接字已经连接到该特定的端口了（见[7.5 #chap7_5]节）。而在某些系统上需要有特权才能绑定到特定的端口（典型的是那些小于1024的端口）。
 - **设置套接字监听**：36-37行
 : 
 ``listen()``函数告诉TCP实现允许来自客户端的连接。在调用``listen()``之前，任何连接到该套接字的请求都会被默默地拒绝??????也就是，在客户端的``connect()``会失败。
+ **反复处理接入连接**：39-59行
 - **接受一个接入连接**：40-47行
 : 
 正如我们上面讨论的，一个调用了``listen()``函数的套接字与客户端程序中的使用不同。服务器程序在套接字上调用``accept()``函数，而不是发送和接收。``accept()``函数阻塞直到在监听的套接字端口上有一个接入的连接为止。在这个时候，``accept()``返回一个新套接字的描述符，它已经连接到了初始的远端套接字。第二个参数是指向一个**sockaddr_in**结构体的指针，第三个参数是指向该结构体大小的 指针。若果连接成功，``sockaddr_in``里有客户
 端所连接的套接字的网络地址和端口号；地址的长度被写入由第三个参数所指的整形指针里面。注意有返回描述符所指的套接字已经被连接了；这意味着已经准备好了发送和接受数据。（对于底层所发生的详情，见[7.4.1 #chap7_4_1]节。
 - **报告连接的客户端**：51-56行
 : 
 现在//clntAddr//含有所连接的客户端的地址和端口号；我们提供一个“呼叫ID”程序并打印客户端信息。它把二进制表示的客户端地址转换为四点分字符串。因为实现使用所谓的网络字节序（见[5.1.2]）来处理端口和地址，所以我们不得不在把端口号传递到``printf()``之前转换它（``inet_pton``是用来转化地址的）。
 - **处理回显客户端**：58行
 : 
 ``HandleTCPClient()``管理“应用程序协议”。我们在下面讨论它。这样我们就提取出了该服务器的特定的“回显”部分。


我们把回显服务器的实现“回显”的部的提取出来。虽然该//应用程序协议//实现起来只有几行，但是把它与其它的代码分离起来在实践中是一个好的设计。

``HandleTCPClient()``从给定的套接字接收数据并且把数据返回到同一个套接字，累接直到``recv()``返回正值为止（指示有数据被接受了）。``recv()``阻塞直到接收到了数据或客户端关闭了连接。当客户端正常的关闭了连接，``recv()``返回0。你可以在``TCPServerUtility.c``文件中找到``HandleTCPClient()``函数。

**HandleTCPClient()**
----------------------------
```
void HanfleTCPClient(int clntSocket)
{
    char buffer[BUFSIZE];   // Buffer for echo string

    // Receive message from client
    ssize_t numBytesRcvd = recv(clntSocket, buffer, BUFSIZE, 0);
    if(numBytesRcvd < 0)
        DieWithSystemMessage("recv() failed");

    // Send received steing and receive again until end of stream
    while(numBytesRcvd > 0) // 0 indicates end of stream
    {
        // Echo message back to client
        ssize_t numBytesSent = send(clntSocket, buffer, numBytesRcvd, 0);
        if(numBytesSent < 0)
            DieWithSystemMessage("send() failed");
        else if(numBytesSent != numBytesRcvd)
            DieWithUserMessage("send()", "send unexpected number of bytes");

        // See if there is more data to rective
        numBytesRcvd = recv(clntSocket, buffer, BUFZIE, 0);
        if(numBytesRcvd < 0)
            DieWithSystemMessage("recv() failed");
    }

    close(clntSocket);  // Close client socket
}
```

假设我们编译``TCPEchoServer4.c``，``DieWithMessage.c``，``TCPServerUtility.c``和``AddressUtility.c``得到可执行程序``TCPEchoServer4``，并在网络地址为``169.1.1.1``的主机上运行该程序，端口号为``5000``。在假设我们在网络地址为``169.1.1.2``的主机上运行我们的客户端连接到服务器。服务器的输出因该为：
```
%TCPEchoServer4 5000
Hangling client 169.1.1.2
```
而客户端的输出像这样：
```
％TCPEchoClient4 169.1.1.2 "Echo this!" 5000
Received: Echo this!
```

服务器把客户端的套接字绑定到端口5000并且等待客户端的连接请求。客户端连接到服务器，发送“Echo this!”消息到服务器，并且接收服务器的回显响应。在该命令中，我们在命令行中给``TCPEchoClient4``提供了断口号，因为它要传递到回显服务器，该断口是5000而不是默认的端口7。


我们在前面已经提到过使用套接字的网络程序一个主要的原则是**自卫程序设计：你的代码必须不要对从网络接收到的任何东西做出假定。**你你怎么“玩”你的TCP服务器来看看它是如何回应客户端的不正确的行为的。你可以写一个TCP客户端来发送伪造的消息并且打印出结果；然而，这样做是既乏味有耗时。一个更快的选择是使用大多数系统上可用的**telnet**程序。这是一个命令行工具，它连接到服务器，发送你所键入的文本，并且打印出回应。Telnet 接受两个参数：服务器和端口。例如：telnet 到我们上面的示例服务器，尝试
```
%telnet 169.1.1.1 5000
```
现在键入你的会显字符串，telnet 将会打印服务器的回应。不同的 telnet 实现间的行为是不一样的，因此你需要研究在你系统上的使用特性。

现在我们已经看过了完整的客户端和服务器，我们就来仔细的看一下组成 Sockets API 的单独函数。

++ 生成和销毁套接字 ++[chap2_3]

为了使用TCP和UDP通信，一个程序首先要叫操作系统生成一个套接字抽象的实例。完成这一功能的函数是``socket(套接字抽象的实例。完成这一功能的函数是``socket()``;它的参数设定了该程序所需要的特性。
```
int socket(int domain, int type, int protocol)
```
第一个参数决定了套接字的通信//域//。我们前面说到：Sockets API 为大量的通信域提供了统一的接口；然而，我们只对IPv4(AF_INET)和IPv6(AF_INET6)感兴趣。注意你可能会看到一些程序使用PF_XXX代替AF_XXX。一般的，这些值是相等的，这种这种情况下它们是相等的，但是这一点是不能保证的。

第二个参数设定套接字的//类型//。类型决定套接字所传输数据的语义——你如：传输是否可靠，消息边界是否有保留，等等。常量 SOCK_STREAM 设置套接字为可靠的字节流语义，而 SOCK_DGRAM 设置为尽最大努力的数据报套接字。

第三个参数设定所使用的特定的//端到端协议//。对于IPv4和IPv6，我们需要TCP（由常量IPPORT_TCP确定）作为流式套接字，或UDP（由IPPORT_UDP确定）作为数据报套接字。为第三个参数提供常量0使得系统为指定的协议族和类型选择默认的端到端的协议。因为一般只选择TCP/IP协议族中的流式套接字，我们直接设定用0来代替协议号。然而，某一天在网络协议里可能会出现另一个端到端的协议实现相同的语义。在这种情况下，设定0可能导致使用一个不同的协议，它可能是或不是我们所需要的。需要确定的主要的事是通信程序使用相同的端到端协议。

我早就说过``socket()``返回一个通信实例的//句柄//。在类Unix系统里，它是一个整形值：成功为非负值，失败为-1。非负值会被当作一个不透明的句柄，像文件描述符一样。（实际上，它就是一个文件描述符，和``open()``函数返回值占用相同大小的空间）这一句柄，我们叫做//套接字描述符//，传递到其它API函数来确定操作将在那个套接字抽象上发生。

当一个应用程序完成了套接字，调用``close()``，所给的套接字描述符将不再需要了。
```
int close(int socket)
```
``close()``告诉底层协议栈开始执行关闭通信和释放该套接字连接的任意资源的行动。``close()``成功返回0，失败返回-1。一但``close()``被调用，涉及到该套接字的其它操作（你如：``send()``和``recv()``）将返回错误。

++ 指定地址 ++[chap2_4]

使用套接字的应用程序需要能够识别它将要通信的远端端点。我们已经知道客户端必须指定它需要通信的服务器程序的地址和端口号。另外，套接字层有时需要传递地址给应用程序。例如：一个与电话系统中的“Caller ID”相似的特点是让服务器知道与之通信的客户端的地址和端口号。

在本节中，我们讨论 Sockets API 中封装这一信息的数据结构。

+++ 一般地址 +++[chap2_4_1] 

Sockets API 定义了一个一般的数据类型——**sockaddr**结构体——来设定所连接的套接字：
```
struct sockaddr 
{
    sa_family_t sa_family;  // Address family(e.g.,AF_INET)
    char sa_data[14];       // Family-specific address information
};
```
地址结构体的第一部分定义了地址族——地址所属的空间。为了我们的目的，我们将总是使用系统定义的常量AF_INET和AF_INET6，它们分别为IPv4和IPv6指定网络地址族。第二部分是一小段字位，它的精确形式依赖于地址族。（这是一种典型的方式来处理操作系统和网络的{{green 不均一性}}--heterogeneity--。）正如我们在[1.2 #chap1_2]节中讨论的，网络协议族的套接字地址有两部分：一个32位（IPv4）或128位（IPv6）的网络地址和一个16位的端口号。

+++ IPv4 地址 +++[chap2_4_2]

TCP/IP 套接字地址所使用的**sockaddr**结构体的特定的部分由IP版本而定，对IPv4来说，使用 **sockaddr_in** 结构体。
```
struct in_addr
{
    uint32_t s_addr;    // Internet address(32 bits)
};

struct sockaddr_in
{
    sa_family sin_family;   // Internet protocol (AF_INET)
    in_port_t sin_port;     // Address port (16 bits)
    struct in_addr sin_addr;// Ipv4 address (32 bits)
    char sin_zero[8];       // Not used
};
```
正如我们看见的，**sockaddr_in**结构体有端口号，网络地址和地址族字段。理解这一点是很重要的：**sockaddr_in**仅仅是**sockaddr**结构体一个详细的数据视图，专门为使用IPv4定制的。这样，我们可以填满**aockaddr_in**结构体，然后把它转换（指针）为一个**sockaddr**（指针）并且传递到套接字函数，查看sa_family来学习他的真正的类型，最后把它转换回合适的类型。

+++ IPv6 地址 +++[chap2_4_3]

对于IPv6，使用**sockaddr_in6**结构体。
```
struct in_addr
{
    uint32_t s_addr[16];    // Internet address (128位)
};

struct sockaddr_in6
{
    sa_family_t sin6_family;    // Internet protocol (AF_INET6)
    in_port_t sin6_port;        // Address port (16 bits)
    uint32_t sin6_flowinfo;     // Flow infornation
    struct in6_addr sin6_addr;  // IPv6 address (128 bits)
    uint_32_t sin6_scope_id;    // Scope identifier
};
```
**sockaddr_in6**结构体中有**sockaddr_in**没有的字段。这些字段是为了满足IPv6的，通常不使用。在本书它们将会被忽略。

如**sockaddr_in**一样，我们必须把**sockaddr_in6**转换到**sockaddr**，从而把它传递到各个套接字函数。再一次，实现使用地址族字段来决定该参数的实际类型。

+++ 一般地址存储 +++[chap2_4_4]

如果你清楚在C中数据结构是如何分配的，你可能已经注意到了一个**aockaddr**没有足够大小来存储一个**sockaddr_in6**。（如果关于这你什么也不知道，不要担心：你需要知道的大部分东西将会在[第五章 #chap5]包含。）特别是我们想要分配一个地址结构，但是我们并不知道真正的地址类型（例如：IPv4或IPv6）是什么？一般的**sockaddr**结构体不能工作，因为对于某些地址结构它太小了。为了解决这一问题，套接字的设计者创造出了**sockaddr_storage**结构体，它保证有足够的大小来支持任何的地址类型。
```
struct sockaddr_storage
{
    sa_family_t
    ...
    // Pading and fields to get correct length and alignent
    ...
};
```
如**sockaddr**一样，我们仍然有前导的族域来确定地址的实际类型；然而，有了**sockaddr_storage**我们就有足够的空间来存储任何类型的地址。（为了示意这是如何完成的，涉及到C编译器如何在内存中放置结构体的讨论，在[5.1.6 #chap5_1_6]中。

关于地址的最后一个注意点。在某些平台上，地址结构体含有一个额外的用于存储地址结构体字节大小的字段。对于**sockaddr,sockaddr_in,sockaddr_in6**和**sockaddr_storage**，该额外的字段分别叫做sa_len，in_len，sin6_len和ss_len。因为长度字段在所有的系统中并不是都有效的，应避免使用它。典型的，在使用这一形式的结构体的定义值（例如：SIN6_LEN）的平台上要在编译期测试是否使用了该长度字段。

+++ 二进制/字符串地址转换 +++[chap2_4_5]

为了是套接字函数理解地址值，它们必须是“数值”（例如：二进制）形式；然而，为了人类使用的地址通常是“可打印的”字符串（例如：192.168.1.1或1::1）。我们可以使用``inet_pton()``（**pton** = **p**rintable **to** **n**umeric）函数来转换可打印的字符串到数值形式：
```
int inet_pton(int addressFamily, const char *src, void *dst)
```
第一个参数，//addressDamily//，指定被转换的地址的地址族。回想一下，Sockets API 为大量的通信域提供了一般化的接口。然而，我们只关心IPv4（AF_INET）和IPv6（AF_INET6）。//src//参数指向一个--null-terninated--字符串，它包含要转换的地址。//dst//参数指向在调用者空间的一块内存，用它来保存转换过的结果；它的长度必须足够保存结果（对于IPv4至少4字节，IPv6至少16字节）。``inet_pton()``转换成功返回1，转换后的地址在//dst//里，以网络字节序存储；如果由//src//指定的字符串不能格式化为有效的地址返回0；如果指定的地址族是未知的返回-1.

我们也可以把地址从数值形式转换到可打印的形式。使用``inet_ntop()``（**ntop** = **n**umeric **to** **p**rintable）：
```
const char *inet_ntop(int addressFamily, const void *src, char *dst, socklen_t dstBytes)
```
第一个参数，//addressFamily//，被转换的地址的地址族。第二个参数//src//指向一个内存快的第一个字节，该内存快包含要转换的数值地址。该快的大小由地址族决定。//dst//参数指向分配在调用者空间的一个缓冲区（一块内存），转换的结果字符串将会被拷贝到这里；它的大小由//dstBytes//给定。我们如何知道要用多大的内存？由系统定义的常量INET_ADDRSTERLEN（用于IPv4）和INET6_ADDRSSTRLEN（用于IPv6）指示结果字符串可能的最长长度（字节）。``inet_ntop()``如果执行成功将返回指向保存可打印地址字符串的指针（例如：第三个参数），否则返回**NULL**。

+++ 使套接字连接到地址 +++[chap2_4_6]

系统把一个本地和外部的地址与每个以连接的套接字（TCP或UDP）联系起来。过一会儿，我们将要讨论这些值是如何分配的详情。我们可以发现这些地址对于本地地址使用``getsockname()``，对于外部地址使用``getpeername()``。这两个函数都返回**sockaddr**结构体，它含有网络地址和端口号。
```
int getpeername(int socket, struct sockaddr *remoteAddress, socklen_t *addressLength)
int getsockname(int socket, struct sockaddr *localAddress, socklen_t *addressLength)
```
//socket//参数是套接字的描述符，它的地址信息是我们所需要的。//remoteAddress//和//localAddress//参数指向地址结构体，其中的地址信息将会有实现进行设定；它们总是被调用者转换到**sockaddr ***。**如果事先我们不知道IP协议版本，我们应该传递一个sockaddr_storage来接收结果。**--As with other socketr calls using **sockaddr**--，//addressLength//是一个输入输出参数，来指定缓冲区（输入）的长度和返回地址结构体（输出）的字节数。

++ 连接到套接字 ++[chap2_5]

一个TCP套接字在通过它传输数据之前必须要连接到另外一个套接字。从这个意义上讲，使用TCP套接字和使用电话网络一样。在你讲话之前，你必须指定你想要的号码，并且一个连接必须被建立；如果不能建立连接，你不得不过后在试一次。连接建立的过程对与客户端和服务器有很大的不同：客户端发起连接而服务器被动等待客户端的连接。（对于连接过程的附加详情和它怎样与API函数相关的，见[7.4 #chap7_4]节。与服务器建立一个连接，我们在套接字上调用``connect()``。
```
int connect(int socket, const struct sockaddr *foreignAddress, socklen_t addressLength)
```
第一个参数，//socket//，是由``socket()``生成的描述符。//foreignAddress//是一个指向**sockaddr**的指针，因为 Sockets API 是一般形式；为了我们的目的，它将总是指向**sockaddr_in**和**sockaddr_in6**，它们包含这服务器的网络地址和端口号。//addressLength//指定地址结构体的长度，典型的由``sizeof(struct sockaddr_in)``或``sizeof(struct sockaddr_in6)``给出。当``connect()``返回，套接字就连接了，并且可以使用``send()``和``recv()``开始通信。

++ 绑定到地址 ++[chap2_6]

正如我们已经注意到的，客户端和服务器“会合”在服务器的地址和端口。为了实现这一目标，服务器必须首先与地址和端口相结合。使用``bind()``来实现这一点。再一次，注意客户端提供服务器的地址给``connect()``，当服务器必须设定它//自己的//地址给``bind()``。为了它们能够通信，无论是客户端该或服务器程序都要知道客户端的地址。（当然，服务器知道客户端的地址或许是为了记录或其它目的。）
```
int bind(int socket, struct sockaddr *localAddress, socklen_t addressSize)
```
第一个参数是由早期调用``socket()``返回的描述符。和``connect()``一样，地址参数是一个指向**sockaddr**的指针，当对于TCP/IP程序，它总是指向**sockaddr_in**（对IPv4）或**sockaddr_in6**（对IPv6），它包含本地接口的网络地址和监听的端口。//addressSize//参数是地址结构体的大小。``bind()``成功返回0，失败返回-1。

认识到这一点是很重要的：一个程序不可能绑定一个套接字到任意的网络地址——如果以给出你一个特定的网络地址（两种类型），调用只有在该地址被分配到程序所运行的主机上的时候才会成功。在一个具有多个网络地址的主机上的服务器可能会绑定到一个特定的地址，因为它只想接受到达该地址的连接。然而，典型的服务器想要接受发送到该主机的任何地址的连接，因此把**sockaddr**的地址部分设置为“统配”地址，IPv4为``INADDR_ANY``，IPv6为``IN6ADDR_ANY``。统配地址的语义是它匹配任何特定的地址。对已一个
服务器来说，它将会接收寻址到该主机的任何地址的连接（具有特定的类型）。

尽管``bind()``大多被服务器使用，但是客户端也可能使用``bind()``来设定它的地址/端口。对那些没有使用``bind()``设定它们的本地地址/端口的TCP客户端，在使用``connect()``期间设定。因此，如果客户端要使用``bind()``则必须在调用``connect()``前调用``bind()``。

你可以使用``IN6ADDR_ANY``来给统配地址初始化一个**in6_addr**结构体；然而，这中特殊常量只能作为在声明中的一种“初始值”使用。**注意：INADDR_ANY 被定义为主机字节序，随后必须使用``htol()``把它转换为网络字节序，在它被``bind()``使用之前，而in6addr_any和IN6ADDR_ANY_INIT已经是网络字节序了。**

最后，如果你给``bind()``提供端口号0，系统将会选择一个没有使用的本地端口给你。

++ 处理接入的连接 ++[chap2_7]

在绑定之后，服务器的套接字有了一个地址（或者至少有一个端口）。另一个步骤是指示底层协议实现来监听来自客户端的连接；改步骤通过在套接字上调用``listen()``来实现。
```
intinsten(int socket, int queueLimit)
```

``listen()``函数是的给定的套接字的内部状态发生改变，因此接入的TCP连接将会被处理并排队等待被程序接受。（见：[7.4 #chap7_4]节，关于TCP连接的生存周期的详细情况）//queueLimit//参数设定在任何时候可以等待的接入连接书的上限。//queueLimit//的精确效果是很依赖系统的，要查看你本地系统的技术规范。``listen()``成功返回0，失败返回-1。

一旦套接字被设置了监听，程序就可以接受客户端的连接。起初服务器在它所建立的套接字上等待连接，接着通过套接字发送和接收数据，最后关闭连接，它一直重复这一过程。可是，这并不是它的工作方式。被绑定到端口和标记为“监听”的套接字实际上从不用于接收和发送。相反，它是用于获得新的套接字的途径，一个客户端连接就生成一个新的套接字；接着服务器就使用该新的套接字就发送和接收数据。服务器调用``accept()``来为一个接入的客户端连接获得一个套接字。
```
int accept(int socket, struct sockaddr *clientAddress, socklen_t *addressLength)
```

改函数把套接字队列中的下一个连接出队。如果队列是空的，``accept()``将阻塞直到一个连接请求到达。当``accept()``调用成功，它将使用连接另一端客户端的地址和端口来填充由//clientAddress//所指向的**sockaddr**结构体。调用时，//addressLength//参数设定//clientAddress//所指向结构体的大小（如：有效的空间）；返回时，它包含实际地址的大小。**一个初学者常犯的错误是错误的初始化了//addressLength//所指的整型值，它包含的是由//clientAddress//所指向的结构体的大小。下面给出了正确的方式：
```
struct sockaddr_storage address;
socllen_t addrLength = sizeof(address);
int newConnection = accept(sock, &address, &addrLength);
```

``accept()``调用成功返回一个连接到客户端的新的套接字的描述符。作为传递到``accept()``的第一个参数的套接字没有改变（没有连接到客户端）并且继续监听新的连接请求。如果失败，``accept()``返回-1。在大多数的系统中，当给``accept()``传递一个坏的套接字描述符它只是调用失败。然而，在某些系统中它会返回一个错误，如果新的套接字在创建之后和被接受之前经历了一个网络级的错误。

++ 通信 ++[chap2_8]

一旦一个套接字“连接了”，你就可以发送和接受数据了。正如我们所看见的，一个客户端通过调用``accept()``生成一个连接的套接字，服务器通过调用``accept()``返回一个连接的套接字。在连接之后，客户端和服务器间的区别就有效的消失了，{{green at least as far as the Sockets API is concerned
}}。通过连接的TCP套接字，你可以使用``send()``和``recv()``来通信。
```
sszie_t send(int socket, const void *msg, size_t msgLength, int flags)
ssize_t recv(int socket, void *rcvBuffer, size_t bufferLength, int flags)
```

这些函数由非常相似的参数。第一个参数//socket//是连接的套接字的描述符通过它来发送和接受数据。对于``send()``，//msg//指向被发送的字节序，//msgLength//是发送的字节书。``send()``的默认动作是阻塞直到所有的数据被发送完。（我们将在[6.3 #chap6_3]节和[第七章 #chap7]重新讨论这一点。）对于``recv()``，//rcvBuffer//指向缓冲区——也就是内存中的一个区域，例如自负数组——接收到的数据将会被放在这里，//buferLength//给出了缓冲区的长度，是一次能够接收的最大字节数。``recv()``的默认行为是阻塞直到至少可以传递一些字节。（在多数系统中，能够让``recv()``去阻塞的最小数据是1字节。

在``send()``和``recv()``两函数中的//flags//参数提供了一种可以改变套接字调用默认行为的某些方面的途径。//flags//设置为0为默认行为。``send()``和``recv()``返回发送或接收的字节数，或失败返回-1。（见[6.3 #chap6_3]节）

记住：TCP是一个流式协议，因此``send()``边界不会被暴力。**接收者调用一次``recv()``所读取的字节数并不是由一次调用``send()``所写入的字节数所必要决定的。**如果你使用``send()``发送3000字节，可能会话费几次``recv()``来获得全部的3000字节，即使你传递5000字节大小的缓冲区给``recv()``。写TCP套接字应用程序的一个常见的错误是假设你用``send()``写入了所有的数据，你可以使用一次``recv()``来读取它。所有的可能性会在[第七章 #chap7]举例说明。

++ 使用IPv6 ++[chap2_9]

到现在为止，我们仅仅看见使用IPv4的客户端和服务器。那怎样使用IPv6呢？变化相对较小，并且基本上涉及使用IPv6的等价的地址结构体和长处。让我们看一下使用IPv6的TCP回显服务器。
**TCPEchoServer6.c**
--------------------------
%!include: ``code/chap2/TCPEchoServer6.c``

 + **套接字生成：19-22行
 : 
 我们通过设定通信域为AF_INET6来生成一个IPv6套接字。
 + **填充本地地址**：24-29行
 : 
 对于本地地址，我们使用IPv6（**structsockaddr_in6）地址结构体和常量（AF_INET6和in6addr_any）。一个微妙的差异是我们不需要把//in6addr_any//转换为网络字节序，如我们给INADDR_ANY所做的一样。
 + **报告连接的客户端**：51-56行
 : 
 //clntAddr//，包含正在连接的客户端的地址，被定义为IPv6套接字地址结构体。当我们把数值表示的地址转换为字符串，最大的字符串长度现在为INET6_ADDRESTRLEN。最后，我们使用IPv6地址调用``inet_ntop()``。

现在你已经看见了IPv4和IPv6的客户端和服务器。在[第三章 #chap3]中我们将看见如何使得使用任何地址类型都可以工作。

== 练习 ==



