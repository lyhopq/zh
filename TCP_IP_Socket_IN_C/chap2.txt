
+ 基本 TCP Socket +[chap2-basic]

现在是你学习 如何写自己的套接字应用程序的时候了。我们将从YCP开始。现在你或许已经做好了直接写一些实际的代码的时候了，因此我们开始进行一个TCP客户端和服务器的工作实例。然后我们呈现在基本TCP中使用的套接字API的细节。为了使事情变得简单，我们最初的代码使用一个特定的IP版本：IPv4，它现在，在很大程度上，仍然在网际协议中占主导地位。在本章的结尾部分，我们讲呈现客户端和服务器的IPv6改进版本。在[第三章 #chap3]我们将要示范创建与协议无关的应用程序。

我们的客户端和服务器例子执行 //echo// 协议。它的工作原理如下：客户端连接到服务器病发送它的数据。服务器简单的回显他所收到的信息到客户端并断开连接。在我们的应用程序中，客户端发送的数据是一个作为提供给命令行参数的字符串。我们的客户端将打印它从服务器收到的数据，这样我们就能看见传回来的是什么东西。许多系统都有一个回显服务来进行调试和测试。

++ IPv4 TCP 客户端 ++[v4_TCP_client]

客户端和服务器之间的区别是非常重要的，因为它们在通信中使用套接字接口的某些步骤不一样。我们首先关注客户端。它的工作就是初始与服务器的通信，服务器被动的等待连接。

典型的TCP客户端通信涉及四个基本步骤：
+ 使用 ``socket()`` 创造一个TCP套接字。
+ 使用 ``connect()`` 与服务器建立连接。
+ 使用 ``send()`` 和 ``recv()`` 通信。
+ 使用 ``close()`` 关闭连接。


``TCPEchoClient4.c`` 是IPv4的TCP回显客户端的实现。

**TCPEchoClient4.c**
----------------------------
%!include: ``code/chap1/TCPEchoClient4.c``

我们的 ``TCPEchoClient4.c`` 做以下事情：

+ **程序建立和参数分析**：1-21行
 - **包含文件**：1-9行
 : 
这些头文件定义了API的标准的函数和常量。查阅你的文档（例如：man手册）的适当头文件找到你系统的套接字函数和数据结构。我们使用我们自己的包含文件：``Practical.h``，有我们自己的函数原型，将在下面描述。

 - **典型的参数分析和完整性检查**：13-21行
 : 
 IPv4地址和回显的字符串作为前两个参数被传递进来。可选择的，客户端把第三个参数作为服务器的端口。如果没有端口参数提供，客户端使用众所周知的回显协议端口：7。
+ **TCP套接字创建**：23-26行
 : 
 我们使用``socket()``函数来创建一个套接字。该套接字对应的是IPv4（AF_INET)，使用叫做TCP（IPPORT_TCP）的流式协议（SOCK_STREAM）。如果成功，``socket()``返回一个整形描述符或“句柄”。如果失败，将返回-1，此时我们调用我们的错误处理函数：``DieWithSystemMessage()``（在后面描述），来打印一个消息来示意并且退出。

+ **准备地址和建立连接**：28-42行
 - **准备sockaddr_in结构体来保存服务器地址**：29-30行
 : 
 连接到一个套接字，我们必须指定连接到的地址和端口。**sockaddr_in**结构体被定义为这些信息的“容器”。调用函数``memset()``的作用是确保我们不需要该结构体中的任何部分都被置零。
 - **填充sockaddr_in**：31-38行
 : 
 我们必须设置地址族（AF_INET），网络地址和端口号。函数``inet_pton()``把服务器的网络地址（作为命令行参数传递了的四点分记法）的字符表示法转换为32位二进制表示法。服务器的端口号在早先已经从命令行字符串转换到了二进制；调用函数``htons()``（"hosttonetworkshort"）确保二进制值格式化为API所需要的。（为什么这样做将在[第五章 #chap5]描述。）
 - **连接**：40-42行
 : 
 函数 ``connect()`` 在所给的socket和 **sockaddr_in** 结构体中由地址和端口所指定的套接字之间建立连接。因为套接字的API是一般形式的，所以指向 ``sockaddr_in`` 地址的结构体指针需要//转换//--cast--成一般的类型(**sockaddr***)，而且必须提供结构体的大小。

+ **发送回显字符串到服务器**：44-51行
 : 
我们找到参数字符串的长度并把它村起来供以后使用。一个指向回显字符串的指针传递到 ``send()`` 函数；该字符串在程序开始的时候被存储到某个位置（如同其它的命令行参数一样。）我们不必要关心它在那个地方；我们仅仅需要知道的是它的第一个字节的地址和有多少字节要被发送。（注意我们不发送字符串结束标记字符(0)，它是参数字符串的结尾——也是所有C中字符串的结尾）``send()``函数如果成功的话返回它所发送的字节数，否则返回-1。如果``send()``失败活发送了错误的自
字节数，我们必须处理这个错误。注意发送错误的字节数在这里将不会出现。不过，有测试代码会是一个好主意，因为在某些情况下错误会发生。

+ **接收回显服务的应答**：53-70行
 : 
TCP是一个字节流的协议。牵扯到这种类型的协议的是``send()``函数的边界没有保留。换句话说：**在连接的一端调用``send()``发送的字节不会在另一端调用一次``recv()``就会全部返回。**（我们将在[第七章 #chap7]详细的讨论这一问题。）因此，我们需要重复的接收字节直到和我们发送的一样多。在所有的可能性中，该循环有被执行一次的情况，因为在服务器上的数据实际上可以被一次返回；然而，这不是//保证//发生的，所以我们不得不允许多次读取需求的可能性。这是写使用套接字程序的基本原则：**你决不要假设网络和另一端的程序将会如何去做。**
 - **接受字节块**：57-65行 
 : 
 ``recv()``阻塞直到数据可用为止，它返回拷贝到缓冲的字节数或者在失败的时候返回-1。返回值为0的时候表示在另一端的应用程序关闭了TCP连接。注意到传递到``recv()``函数的字节大小参数为添加一个终止字符保留了空间。
 - **打印缓冲**：66-77行
 : 
 我们打印由服务器发送的数据，也是服务器所接收的。我们在每一个接收快的结尾添加一个结束标志(0)，因此它可以被``fputs()``作为一个字符串。我们没有检查接收到的数据是否和发送的一致。服务器可以发送完全不一样的东西（直到和我们发送的字符串长度一样），并且它将被写到标准输出。
 - **打印新行**：70行
 : 
 当接收到和发送的一样多的字节时，我们结束循环并且打印一个新行。

+ **结束连接病退出**：72-73行
 : 
 ``close()``函数通知远端套接字连接被终止了，然后解除套接字使用的本地资源。


处理函数：
```
DieWithUserMessage(const char *msg, const char *detail)
DieWithSystemMessage(const char *msg)
```

这两个函数打印用户提供的消息（//msg//）到//stderr//，还有一个详细的消息字符串；然后它们调用一个带有错误返回码的``exit()``函数，来终止应用程序。

它们的唯一区别是详细消息的来源。对于``DieWithUserMessage()``函数，详细消息是用户提供的。对于``DieWithSystemMessage()``函数，详细消息是由系统基于特定的//errno//（它描述了最近失败的原因，如果有的话）值来提供的。我们仅仅只在错误状态是由调用一个系统函数时设置了//errno//时，来调用``DieWithSystemMessage()``。（为了使程序简单，我们的示例没有包含太多的从错误中恢复的代码——只是简单的
--punt--和退出。作品级的代码不会这样轻易的放弃的。）

偶尔，我们需要提供给用户一些信息而不退出程序；如果我们需要格式化功能的话则使用``printf()``函数，其它情况下使用``fputs()``函数。特别的，在输出固定的，预先格式化的字符串时，我们尽量不要使用``printf()``函数。**你//绝不要//干的一件事情是：把从网络接收的文本作为第一个字符串传给``printf()``函数。这样做会产生一个严重的安全漏洞。在这种情况下使用``fputs()``代替。**

: 
**注意：**函数``DieWith...()``在头文件``"Practical.h"``中//申明//。然而，这些函数的//实现//在``DieWithMessage.c``中，它应该被本文说有的例子程序编译和连接。


**DieWithMessage.c**
----------------------------
%!include: ``code/chap1/DieWithMessage.c``


如果我们编译了``TCPEchoClient4.c``和``DieWithMessage.c``将会生成程序``TCPEchoClient4，我们可以使用如下方式和一个网络地址为``169.1.1.1``的回显服务器通信：
: 
```
%TCPEchoClient4 169.1.1.1 "Echo this!"
Received: Echo this!
```

为了使客户端能够工作，我们需要服务程序。许多系统有回显服务用来调试和测试；然而，为了安全起见，这些服务在初始化是被禁用的。如果你不能访问回显服务，没有关系因为我们将要写一个。


++ IPv4 TCP 服务器 ++

现在我们把注意力集中在TCP服务器上。该服务器的工作是建立一个通信端点和被动的等待客户端的连接。TCP服务器通信有四个基本步骤：
 + 使用``socket()``产生一个TCP套接字。
 + 使用``bind()``给该套接字分配一个端口号。
 + 使用``listen()``告诉系统该端口允许接受连接。
 + 重复的做一下事情：
  - 调用``accept()``给每一个客户端连接一个套接字。
  - 通过新的套接字使用``send()``和``recv()``与客户端通信。
  - 使用``close()``关闭客户端的连接。


建造一个套接字，发送，接收，关闭这和客户端是一样的。不同之处在于在服务器中的套接字必须要和一个地址绑定,然后使用该套接字作为一种方式来获得与客户端连接的套接字。（我们将在下面的代码中阐述这一点。）服务器和每一个客户端的连接可以使这样简单：它简单的在客户端连接时接收数据并吧接收的数据返回客户端；他重复这一过程直到客户端结束连接，至此就不再有数据到来。

**TCPEchoCServer4.c**
---------------------------
%!include: ``code/chap1/TCPEchoServer4.c``

+ **程序建立和参数解析**：1-17行
: 
我们使用``atoi()``把端口号从字符串转换到数字值；如果第一个参数不是数，``atoi()``将返回0，这将会产生一个错误在我们调用``bind()``的时候。
+ **套接字生成和建立**：19-37行
 - **生成一个TCP套接字**：20-37行
 : 
 生成一个流失套接字就像我们在客户端中做的一样。
 - **找到想要的端点地址**：25-29行
 : 
 在服务器端，我们需要把我们的服务端套接字与一个地址和端口号联系起来，这样客户端的连接才能找到正确的地方。既然本程序是为IPv4写的，我们就给它使用**sockaddr_in**结构体。因为我们并不关心所连接的地址（指定到运行该服务器的机器的如何地址都可以。）在设置**sockaddr_in**地址和端口号之前，我们使用``htonl()``和
 ``htons``把它们分别转换到网络字节序。（详见[5.1.2 #chap5.1.2]）
 - **绑定套接字到指定地址和端口**：32-33行
 : 
 如上面所注解，服务器套接字需要和一个本地地址和端口相关联；完成这一过程的是``bind()``函数。注意**客户端必须给``connect()``提供服务器的地址，二服务器必须给``bind()``指定//它自己//的地址。**就是有这一信息（如：服务器的地址和端口），它们才同意通信。注意``bind()``失败有几种原因；其中最重要的一种是有其它的套接字已经连接到该特定的端口了（见[7.5 #chap7.5]节）。而在某些系统上需要有特权才能绑定到特定的端口（典型的是那些小于1024的端口）。
 - **设置套接字监听**：36-37行
 : 
 ``listen()``函数告诉TCP实现允许来自客户端的连接。在调用``listen()``之前，任何连接到该套接字的请求都会被默默地拒绝——也就是，在客户端的``connect()``会失败。
+ **反复处理接入连接**：39-59行
 - **接受一个接入连接**：40-47行







